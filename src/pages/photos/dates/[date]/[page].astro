---
import PhotoIndexPageLayout from "../../../../layouts/PhotoIndexPageLayout.astro"
import Hero from "../../../../components/Hero.astro"
import { getCollection } from "astro:content"
import type { PhotoManifestItem } from "../../../../utils/photoManifestSchema"
import type { GetStaticPathsResult, PaginateFunction, Page } from "astro"
import { formatDateString } from "../../../../utils/photoHelpers"

interface Props {
  page: Page<PhotoManifestItem> // items will have slugs from manifest
  dateDisplay: string
  fullPhotoDataset: PhotoManifestItem[] // The dataset for THIS date, with slugs
}

export async function getStaticPaths({
  paginate,
}: {
  paginate: PaginateFunction
}): Promise<GetStaticPathsResult> {
  const PAGE_SIZE = 24 // Define page size inside getStaticPaths

  // Fetch all photos from the collection (cached by Astro)
  const photoEntries = await getCollection("photos")
  const allPhotos: PhotoManifestItem[] = photoEntries.map(
    (entry) => entry.data as PhotoManifestItem
  )

  const photosByDate = new Map<string, PhotoManifestItem[]>()
  allPhotos.forEach((photo) => {
    let dateStr: string | null = null
    if (photo.dateTaken) {
      dateStr = photo.dateTaken.substring(0, 10) // YYYY-MM-DD
    } else if (photo.year && photo.month && photo.day) {
      const monthStr = String(photo.month).padStart(2, "0")
      const dayStr = String(photo.day).padStart(2, "0")
      dateStr = `${photo.year}-${monthStr}-${dayStr}`
    }

    if (dateStr) {
      if (!photosByDate.has(dateStr)) {
        photosByDate.set(dateStr, [])
      }
      photosByDate.get(dateStr)?.push(photo)
    }
  })

  const paths = []
  for (const [date, photosOnDate] of photosByDate.entries()) {
    // Sort photos on this specific date by time (if available in dateTaken)
    photosOnDate.sort((a, b) => {
      if (a.dateTaken && b.dateTaken) {
        const dateA = new globalThis.Date(a.dateTaken)
        const dateB = new globalThis.Date(b.dateTaken)

        const timeA = dateA.getTime()
        const timeB = dateB.getTime()

        if (isNaN(timeA) && isNaN(timeB)) return 0 // Both invalid, treat as equal
        if (isNaN(timeA)) return 1 // Invalid dateA goes to the end
        if (isNaN(timeB)) return -1 // Invalid dateB goes to the end

        return timeA - timeB // Earliest first for a given day
      }
      return 0
    })

    const paginatedResult = paginate(photosOnDate, {
      pageSize: PAGE_SIZE,
      params: { date: date },
      props: {
        dateDisplay: date,
        fullPhotoDataset: photosOnDate, // Pass ONLY the photos for THIS date
      },
    })
    paths.push(...paginatedResult)
  }
  return paths
}

// Props interface is now Props defined above
const { page, dateDisplay, fullPhotoDataset } = Astro.props // Added fullPhotoDataset

// Format date to human-readable format
const formattedDate = formatDateString(dateDisplay)

const pageTitle = `Photos from ${formattedDate}`
const pageDescription = `A collection of photos taken on ${formattedDate}. Page ${page.currentPage} of ${page.lastPage}.`
---

<PhotoIndexPageLayout
  page={page}
  fullPhotoDataset={fullPhotoDataset}
  pageTitle={pageTitle}
  pageDescription={pageDescription}
  currentNav="dates"
>
  <Hero slot="heroContent">
    <h1>{pageTitle}</h1>
  </Hero>
</PhotoIndexPageLayout>

---
import PhotoIndexPageLayout from "../../../../layouts/PhotoIndexPageLayout.astro"
import Hero from "../../../../components/Hero.astro"
import type { PhotoManifestItem } from "../../../../utils/photoManifestSchema"
import { getCollection } from "astro:content"
import type { Page, PaginateFunction, GetStaticPathsResult } from "astro"

export async function getStaticPaths({
  paginate,
}: {
  paginate: PaginateFunction
}): Promise<GetStaticPathsResult> {
  const PAGE_SIZE = 24 // Defined inside function

  // Fetch all photos from the collection (cached by Astro)
  const photoEntries = await getCollection("photos")
  const fetchedPhotos: PhotoManifestItem[] = photoEntries.map(
    (entry) => entry.data as PhotoManifestItem
  )

  // Slugs are now assumed to be in fetchedPhotos from the manifest.
  // No need for: const allPhotosWithSlugs = ...

  const photosByTag = new Map<string, PhotoManifestItem[]>()
  fetchedPhotos.forEach((photo) => {
    // Use fetchedPhotos directly
    if (photo.tags && photo.tags.length > 0) {
      photo.tags.forEach((tag) => {
        const lowerCaseTag = tag.toLowerCase()
        if (!photosByTag.has(lowerCaseTag)) {
          photosByTag.set(lowerCaseTag, [])
        }
        photosByTag.get(lowerCaseTag)?.push(photo) // photo has slug from manifest
      })
    }
  })

  const paths = []
  for (const [tag, photosForTag] of photosByTag.entries()) {
    // photosForTag items will have slugs
    // Sort photos within this tag group by dateTaken, most recent first
    photosForTag.sort((a, b) => {
      if (a.dateTaken && b.dateTaken) {
        return new Date(b.dateTaken).getTime() - new Date(a.dateTaken).getTime()
      }
      if (a.dateTaken) return -1
      if (b.dateTaken) return 1
      return 0
    })

    // Astro's paginate function will handle the `page` param from the filename [page].astro
    const paginatedResult = paginate(photosForTag, {
      pageSize: PAGE_SIZE,
      params: { tag: encodeURIComponent(tag) }, // Pass the 'tag' param
      props: {
        tagDisplayName: tag,
        fullPhotoDataset: photosForTag, // Pass ONLY the photos for THIS tag
      },
    })
    paths.push(...paginatedResult)
  }
  return paths
}

interface Props {
  page: Page<PhotoManifestItem> // page prop is automatically populated by paginate, items will have slugs
  tagDisplayName: string // From getStaticPaths props
  fullPhotoDataset: PhotoManifestItem[] // The dataset for THIS tag, with slugs
}

const { page, tagDisplayName, fullPhotoDataset } = Astro.props // fullPhotoDataset is now scoped to the tag
// const { tag } = Astro.params; // 'tag' is still available from Astro.params if needed,
// and 'page' (the number) would be Astro.params.page

// Use tagDisplayName for display, as it preserves original casing
const pageTitle = `Photos tagged: "${tagDisplayName}"`
const pageDescription = `A collection of photos tagged with "${tagDisplayName}". Page ${page.currentPage} of ${page.lastPage}.`
---

<PhotoIndexPageLayout
  page={page}
  fullPhotoDataset={fullPhotoDataset}
  pageTitle={pageTitle}
  pageDescription={pageDescription}
>
  <Hero slot="heroContent">
    <h1>{pageTitle}</h1>
  </Hero>
</PhotoIndexPageLayout>

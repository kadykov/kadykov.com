---
/**
 * Search modal overlay with Pagefind integration.
 * Uses the native <dialog> element for accessibility.
 * Pagefind assets are loaded lazily on first open.
 */
---

<dialog id="search-modal" aria-label="Site search">
  <div class="search-modal-content">
    <header>
      <h2>Search</h2>
      <button
        type="button"
        class="close-button"
        aria-label="Close search"
        autofocus
      >
        &times;
      </button>
    </header>
    <div class="search-container">
      <input
        type="text"
        id="search-input"
        placeholder="Search the site..."
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
      />
      <div id="search-results" aria-live="polite"></div>
    </div>
    <footer>
      <p>Press <kbd>Esc</kbd> to close</p>
    </footer>
  </div>
</dialog>

<script>
  /**
   * Pagefind browser API types (loaded dynamically at runtime).
   * These match the API generated by the Pagefind CLI at build time.
   * The JavaScript file itself comes from /pagefind/pagefind.js (not node_modules).
   *
   * Note: The pagefind npm package only contains the CLI tool (Node.js).
   * The browser-side JavaScript is generated when running `npx pagefind --site dist`.
   */
  interface PagefindResult {
    url: string
    excerpt: string
    meta: {
      title?: string
      image?: string
      [key: string]: string | undefined
    }
  }

  interface PagefindSearchResult {
    id: string
    data: () => Promise<PagefindResult>
  }

  interface PagefindSearch {
    results: PagefindSearchResult[]
  }

  interface PagefindAPI {
    init: () => Promise<void>
    search: (query: string) => Promise<PagefindSearch>
  }

  // Track if Pagefind has been loaded
  let pagefindLoaded = false
  let pagefindInstance: PagefindAPI | null = null

  async function loadPagefind(): Promise<PagefindAPI | null> {
    if (pagefindLoaded && pagefindInstance) {
      return pagefindInstance
    }

    try {
      // Dynamic import of the browser API generated by Pagefind CLI.
      // @vite-ignore: Prevents Vite from resolving this at build time (it doesn't exist yet).
      // @ts-expect-error: File is generated by `npx pagefind` after build, not in source.
      const pagefind = await import(/* @vite-ignore */ "/pagefind/pagefind.js")
      await pagefind.init()
      pagefindInstance = pagefind
      pagefindLoaded = true
      return pagefind
    } catch (error) {
      console.warn(
        "Pagefind not available. Run 'just index' to build the search index.",
        error
      )
      return null
    }
  }

  function debounce<T extends (...args: string[]) => void>(
    fn: T,
    delay: number
  ): T {
    let timeoutId: ReturnType<typeof setTimeout>
    return ((...args: Parameters<T>) => {
      clearTimeout(timeoutId)
      timeoutId = setTimeout(() => fn(...args), delay)
    }) as T
  }

  async function performSearch(query: string): Promise<void> {
    const resultsContainer = document.getElementById("search-results")
    if (!resultsContainer) return

    if (!query.trim()) {
      resultsContainer.innerHTML = ""
      return
    }

    const pf = await loadPagefind()
    if (!pf) {
      resultsContainer.innerHTML =
        '<p class="search-message">Search is not available. The index needs to be built.</p>'
      return
    }

    try {
      const search = await pf.search(query)

      if (search.results.length === 0) {
        resultsContainer.innerHTML = `<p class="search-message">No results found for "<strong>${escapeHtml(query)}</strong>"</p>`
        return
      }

      // Load the first 10 results
      const results = await Promise.all(
        search.results.slice(0, 10).map((r: PagefindSearchResult) => r.data())
      )

      resultsContainer.innerHTML = `
        <ul class="search-results-list">
          ${results
            .map(
              (result: PagefindResult) => `
            <li>
              <a href="${result.url}">
                <strong>${result.meta.title || "Untitled"}</strong>
                <span>${result.excerpt}</span>
              </a>
            </li>
          `
            )
            .join("")}
        </ul>
        ${search.results.length > 10 ? `<p class="search-message">${search.results.length - 10} more results...</p>` : ""}
      `
    } catch (error) {
      console.error("Search error:", error)
      resultsContainer.innerHTML =
        '<p class="search-message">An error occurred while searching.</p>'
    }
  }

  function escapeHtml(text: string): string {
    const div = document.createElement("div")
    div.textContent = text
    return div.innerHTML
  }

  function initSearchModal() {
    const modal = document.getElementById("search-modal") as HTMLDialogElement
    const closeButton = modal?.querySelector(".close-button")
    const searchInput = document.getElementById(
      "search-input"
    ) as HTMLInputElement

    if (!modal) return

    // Close on backdrop click
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        modal.close()
      }
    })

    // Close button
    closeButton?.addEventListener("click", () => {
      modal.close()
    })

    // Debounced search on input
    const debouncedSearch = debounce((query: string) => {
      performSearch(query)
    }, 200)

    searchInput?.addEventListener("input", (e) => {
      const target = e.target as HTMLInputElement
      debouncedSearch(target.value)
    })

    // Clear results when modal closes
    modal.addEventListener("close", () => {
      if (searchInput) {
        searchInput.value = ""
      }
      const resultsContainer = document.getElementById("search-results")
      if (resultsContainer) {
        resultsContainer.innerHTML = ""
      }
    })

    // Keyboard shortcut: Cmd/Ctrl + K to open search
    document.addEventListener("keydown", (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "k") {
        e.preventDefault()
        if (modal.open) {
          modal.close()
        } else {
          modal.showModal()
          searchInput?.focus()
        }
      }
    })
  }

  // Run on initial load
  initSearchModal()

  // Re-run after view transitions
  document.addEventListener("astro:page-load", initSearchModal)
</script>

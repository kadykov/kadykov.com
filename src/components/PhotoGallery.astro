---
import OptimizedImage from "./OptimizedImage.astro"
import type { PhotoManifestItem } from "../utils/photoManifestSchema"
import { getImage } from "astro:assets"
import { classifyPhoto, getImageDimensions } from "../utils/photoClassification" // Import classification utilities

interface Props {
  photos: PhotoManifestItem[] // Photos for the current paginated view (thumbnails)
  fullPhotoDataset?: PhotoManifestItem[] // Optional: Full dataset for PhotoSwipe context
}

const { photos, fullPhotoDataset } = Astro.props
const imageBaseUrl = "https://share.kadykov.com/"

// Determine the dataset to use for PhotoSwipe. Fallback to current page's photos if full dataset isn't provided.
const pswpDataset =
  fullPhotoDataset && fullPhotoDataset.length > 0 ? fullPhotoDataset : photos

// Prepare a simplified dataset for PhotoSwipe to embed as JSON
// Use Astro's layout system to generate consistent srcsets
const photoSwipeJsonData = await Promise.all(
  pswpDataset.map(async (photo) => {
    const photoSrc = `${imageBaseUrl}${photo.relativePath}`

    // Generate AVIF srcset using Astro's full-width layout (for lightbox full-screen viewing)
    let pswpSrcset = ""
    try {
      const avifLightboxImages = await getImage({
        src: photoSrc,
        width: photo.width, // True intrinsic width
        height: photo.height, // True intrinsic height
        format: "avif",
        layout: "full-width", // Let Astro generate appropriate srcset for full-width display
      })
      pswpSrcset = avifLightboxImages?.srcSet?.attribute || ""
    } catch (e) {
      // console.error(`Failed to generate AVIF srcset for ${photoSrc}:`, e);
      // pswpSrcset will remain empty, PhotoSwipe will use the main 'src'
    }

    // Generate a medium-sized WebP for the main 'src' (fallback for PhotoSwipe display)
    // Exactly 1600px max, maintaining aspect ratio, no 2x variants
    const MAX_WIDTH = 1600
    let webpSrcForPswp = photoSrc // Default to original if WebP generation fails
    try {
      // Calculate dimensions maintaining aspect ratio
      const fallbackWidth = Math.min(MAX_WIDTH, photo.width)
      const fallbackHeight = Math.round(
        (photo.height / photo.width) * fallbackWidth
      )

      const webpPswpDisplayImage = await getImage({
        src: photoSrc,
        width: fallbackWidth,
        height: fallbackHeight,
        format: "webp",
        // No layout property - generates exactly one image at specified dimensions
      })
      if (webpPswpDisplayImage?.src) {
        webpSrcForPswp = webpPswpDisplayImage.src
      }
    } catch (e) {
      // console.error(`Failed to generate WebP display image for ${photoSrc}:`, e);
    }

    // Generate a small WebP for 'msrc' (placeholder) - exactly 300px wide, no 2x variant
    const PLACEHOLDER_MAX_WIDTH = 300
    let msrcUrl = webpSrcForPswp // Default to medium WebP if small one fails
    try {
      // Calculate dimensions maintaining aspect ratio
      const placeholderWidth = Math.min(PLACEHOLDER_MAX_WIDTH, photo.width)
      const placeholderHeight = Math.round(
        (photo.height / photo.width) * placeholderWidth
      )

      const placeholderImage = await getImage({
        src: photoSrc,
        width: placeholderWidth,
        height: placeholderHeight,
        format: "webp",
        // No layout property - generates exactly one image at specified dimensions
      })
      if (placeholderImage?.src) {
        msrcUrl = placeholderImage.src
      }
    } catch (e) {
      // console.error(`Failed to generate msrc placeholder for ${photoSrc}:`, e);
    }

    return {
      downloadUrl: photoSrc, // Original JPEG for download
      src: webpSrcForPswp, // Optimized WebP for main display fallback
      msrc: msrcUrl, // Small WebP placeholder
      w: photo.width, // PhotoSwipe expects 'w' (original dimensions)
      h: photo.height, // PhotoSwipe expects 'h' (original dimensions)
      srcset: pswpSrcset, // AVIF srcset for PhotoSwipe
      title: photo.title || "",
      description: photo.description || "",
      dateTaken: photo.dateTaken || "",
      tags: photo.tags || [],
      slug: photo.slug || "", // Slug for deep linking
    }
  })
)

// Helper function to generate a random rotation angle for Polaroid-style scatter effect
// Uses normal (Gaussian) distribution for more natural-looking scatter:
// - Most cards will be nearly straight (close to 0°)
// - Fewer cards will have extreme rotations
// Returns a value between -maxDegrees and +maxDegrees, with 68% within ±(maxDegrees/2)
function getRandomRotation(maxDegrees: number = 1): number {
  // Box-Muller transform to generate normally distributed random values
  const u1 = Math.random()
  const u2 = Math.random()
  const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2)

  // z0 is now normally distributed with mean=0, stddev=1
  // Scale so that 2 standard deviations ≈ maxDegrees (95% of values within range)
  const rotation = z0 * (maxDegrees / 2)

  // Clamp to ensure we never exceed maxDegrees (handles extreme outliers)
  return Math.max(-maxDegrees, Math.min(maxDegrees, rotation))
}
---

{
  photos && photos.length > 0 ? (
    // CSS Grid masonry layout with aspect ratio classes
    <ul id="gallery">
      {/* Embed the full dataset for PhotoSwipe, ensuring it's not HTML-escaped */}
      <script
        is:inline
        type="application/json"
        id="photoswipe-data"
        set:html={JSON.stringify(photoSwipeJsonData)}
      />

      {/* Render thumbnails for the current page */}
      {photos.map(async (photo, pageSpecificIndex) => {
        // Find the index of this 'photo' within the 'pswpDataset' (which is fullPhotoDataset)
        // This index is crucial if PhotoSwipe uses a JS dataSource.
        const fullDatasetIndex = pswpDataset.findIndex(
          (p) => p.slug === photo.slug && p.relativePath === photo.relativePath
        )

        const photoSrc = `${imageBaseUrl}${photo.relativePath}` // Original JPEG/PNG src
        const altText = photo.title || photo.description || photo.filename

        // Retrieve the pre-generated data for this photo from photoSwipeJsonData
        // All optimized images (AVIF srcset, WebP fallback, placeholder) are pre-generated
        const pswpEntryForThisPhoto = photoSwipeJsonData.find(
          (entry) => entry.slug === photo.slug && entry.downloadUrl === photoSrc
        )

        // For PhotoSwipe data attributes:
        // href: Medium-sized WebP for the link preview
        // data-pswp-src: Original JPEG for download
        // data-pswp-srcset: AVIF srcset for responsive lightbox display
        // data-pswp-width/height: Original dimensions
        const pswpLinkHref = pswpEntryForThisPhoto?.src || photoSrc
        const pswpDataSrc = pswpEntryForThisPhoto?.downloadUrl || photoSrc
        const pswpWidth = photo.width
        const pswpHeight = photo.height
        const pswpSrcset = pswpEntryForThisPhoto?.srcset || ""

        // Use the two-step classification system to determine caption placement and grid span
        const classification = classifyPhoto(photo.width, photo.height)
        const captionClass = classification.captionClass // 'caption-bottom' or 'caption-side'
        const gridClass = classification.gridClass // 'grid-landscape', 'grid-square', or 'grid-portrait'

        // Calculate optimal image dimensions based on grid layout and caption placement
        // This accounts for: grid columns, gaps, padding, and responsive rem scaling (16px-22px)
        const { displayWidth, sizesAttr } = getImageDimensions(classification)

        // Generate a random rotation for this card (build-time, not runtime)
        const cardRotation = getRandomRotation(1).toFixed(2) // Random rotation mostly between -1deg and +1deg, rounded to 2 decimal places

        return (
          <li class={`${captionClass} ${gridClass}`}>
            <a
              class="gallery-item"
              href={pswpLinkHref}
              data-pswp-src={pswpDataSrc}
              data-pswp-width={pswpWidth}
              data-pswp-height={pswpHeight}
              data-pswp-srcset={pswpSrcset}
              data-title={photo.title || ""}
              data-description={photo.description || ""}
              data-date={photo.dateTaken || ""}
              data-tags={photo.tags?.join(",") || ""}
              data-slug={photo.slug || ""}
              data-pswp-index={
                fullDatasetIndex === -1 ? pageSpecificIndex : fullDatasetIndex
              }
              target="_blank"
              aria-label={`View image ${altText}`}
            >
              <figure style={`rotate: ${cardRotation}deg;`}>
                <OptimizedImage
                  src={photoSrc}
                  alt={altText}
                  width={displayWidth}
                  originalWidth={photo.width}
                  originalHeight={photo.height}
                  sizesAttr={sizesAttr}
                  loading="lazy"
                  decoding="async"
                />
                <figcaption>{photo.title || photo.filename}</figcaption>
              </figure>
            </a>
          </li>
        )
      })}
    </ul>
  ) : (
    <p>No photos to display.</p>
  )
}

<script>
  // This ensures src/scripts/photoswipe.js is processed by Vite/Astro and included in the build.
  // The script itself (photoswipe.js) will then initialize PhotoSwipe on the #gallery.
  import "../scripts/photoswipe.js"
</script>

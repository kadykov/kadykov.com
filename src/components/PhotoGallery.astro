---
import OptimizedImage from "./OptimizedImage.astro"
import type { PhotoManifestItem } from "../utils/photoManifestSchema"
import { getImage } from "astro:assets"
import { widthSet as globalWidthSet } from "../utils/widthSet" // Import global widthSet
import { classifyPhoto, getImageDimensions } from "../utils/photoClassification" // Import classification utilities

interface Props {
  photos: PhotoManifestItem[] // Photos for the current paginated view (thumbnails)
  fullPhotoDataset?: PhotoManifestItem[] // Optional: Full dataset for PhotoSwipe context
}

const { photos, fullPhotoDataset } = Astro.props
const imageBaseUrl = "https://share.kadykov.com/"

// Determine the dataset to use for PhotoSwipe. Fallback to current page's photos if full dataset isn't provided.
const pswpDataset =
  fullPhotoDataset && fullPhotoDataset.length > 0 ? fullPhotoDataset : photos

// Prepare a simplified dataset for PhotoSwipe to embed as JSON
// This now includes avifSrcset for each image in the full dataset.
const photoSwipeJsonData = await Promise.all(
  pswpDataset.map(async (photo) => {
    const photoSrc = `${imageBaseUrl}${photo.relativePath}`
    const calculatedLightboxWidths = getLightboxWidths(photo.width) // Ensure getLightboxWidths is defined above or passed

    let pswpSrcset = ""
    try {
      const avifLightboxImages = await getImage({
        src: photoSrc,
        widths: calculatedLightboxWidths,
        width: photo.width, // True intrinsic width
        height: photo.height, // True intrinsic height
        format: "avif",
      })
      pswpSrcset = avifLightboxImages?.srcSet?.attribute || ""
    } catch (e) {
      // console.error(`Failed to generate AVIF srcset for ${photoSrc}:`, e);
      // pswpSrcset will remain empty, PhotoSwipe will use the main 'src'
    }

    // Generate a medium WebP for the main 'src' (fallback for PhotoSwipe display)
    // Aim for max dimension (width or height) around 1600px, maintaining aspect ratio.
    const MAX_DIMENSION = 1600
    let targetWidth = photo.width
    let targetHeight = photo.height

    if (photo.width > MAX_DIMENSION || photo.height > MAX_DIMENSION) {
      if (photo.width / photo.height > 1) {
        // Landscape or square
        targetWidth = MAX_DIMENSION
        targetHeight = Math.round((photo.height / photo.width) * targetWidth)
      } else {
        // Portrait
        targetHeight = MAX_DIMENSION
        targetWidth = Math.round((photo.width / photo.height) * targetHeight)
      }
    }
    // Ensure dimensions are at least 1px
    targetWidth = Math.max(1, targetWidth)
    targetHeight = Math.max(1, targetHeight)

    let webpSrcForPswp = photoSrc // Default to original if WebP generation fails
    try {
      const webpPswpDisplayImage = await getImage({
        src: photoSrc,
        width: targetWidth,
        height: targetHeight,
        format: "webp",
      })
      if (webpPswpDisplayImage?.src) {
        webpSrcForPswp = webpPswpDisplayImage.src
      }
    } catch (e) {
      // console.error(`Failed to generate WebP display image for ${photoSrc} (target ${targetWidth}x${targetHeight}):`, e);
    }

    // Generate a small WebP for 'msrc' (placeholder) - max width 300px
    const placeholderMaxWidth = 300
    let msrcPlaceholderWidth = Math.min(placeholderMaxWidth, photo.width)
    let msrcPlaceholderHeight = Math.round(
      (photo.height / photo.width) * msrcPlaceholderWidth
    )
    // Ensure dimensions are at least 1px
    msrcPlaceholderWidth = Math.max(1, msrcPlaceholderWidth)
    msrcPlaceholderHeight = Math.max(1, msrcPlaceholderHeight)

    let msrcUrl = webpSrcForPswp // Default to medium WebP if small one fails
    try {
      const placeholderImage = await getImage({
        src: photoSrc,
        width: msrcPlaceholderWidth,
        height: msrcPlaceholderHeight,
        format: "webp",
      })
      if (placeholderImage?.src) {
        msrcUrl = placeholderImage.src
      }
    } catch (e) {
      // console.error(`Failed to generate msrc placeholder for ${photoSrc} (target ${msrcPlaceholderWidth}x${msrcPlaceholderHeight}):`, e);
    }

    return {
      downloadUrl: photoSrc, // Original JPEG for download
      src: webpSrcForPswp, // Optimized WebP for main display fallback
      msrc: msrcUrl, // Small WebP placeholder
      w: photo.width, // PhotoSwipe expects 'w' (original dimensions)
      h: photo.height, // PhotoSwipe expects 'h' (original dimensions)
      srcset: pswpSrcset, // AVIF srcset for PhotoSwipe
      title: photo.title || "",
      description: photo.description || "",
      dateTaken: photo.dateTaken || "",
      tags: photo.tags || [],
      slug: photo.slug || "", // Slug for deep linking
    }
  })
)

// Helper function to calculate lightbox widths, implementing user's "replace largest" logic.
function getLightboxWidths(photoWidth: number): number[] {
  if (photoWidth <= 0) return [] // Handle invalid photoWidth

  let widths = globalWidthSet.filter((w) => w <= photoWidth)

  if (widths.length > 0) {
    // If there are global widths <= photoWidth, remove the largest among them.
    const maxGlobalWidth = Math.max(...widths)
    widths = widths.filter((w) => w !== maxGlobalWidth)
  }
  // Always add the actual photoWidth.
  widths.push(photoWidth)

  // Handle cases where photoWidth was very small and widths might be just [photoWidth]
  // or if globalWidthSet was empty.
  if (widths.length === 0 && photoWidth > 0) {
    // This condition might be redundant due to push(photoWidth)
    widths = [photoWidth]
  }

  return [...new Set(widths)].sort((a, b) => a - b)
}

// Helper function to generate a random rotation angle for Polaroid-style scatter effect
// Uses normal (Gaussian) distribution for more natural-looking scatter:
// - Most cards will be nearly straight (close to 0°)
// - Fewer cards will have extreme rotations
// Returns a value between -maxDegrees and +maxDegrees, with 68% within ±(maxDegrees/2)
function getRandomRotation(maxDegrees: number = 1): number {
  // Box-Muller transform to generate normally distributed random values
  const u1 = Math.random()
  const u2 = Math.random()
  const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2)

  // z0 is now normally distributed with mean=0, stddev=1
  // Scale so that 2 standard deviations ≈ maxDegrees (95% of values within range)
  const rotation = z0 * (maxDegrees / 2)

  // Clamp to ensure we never exceed maxDegrees (handles extreme outliers)
  return Math.max(-maxDegrees, Math.min(maxDegrees, rotation))
}
---

{
  photos && photos.length > 0 ? (
    // CSS Grid masonry layout with aspect ratio classes
    <ul id="gallery">
      {/* Embed the full dataset for PhotoSwipe, ensuring it's not HTML-escaped */}
      <script
        is:inline
        type="application/json"
        id="photoswipe-data"
        set:html={JSON.stringify(photoSwipeJsonData)}
      />

      {/* Render thumbnails for the current page */}
      {photos.map(async (photo, pageSpecificIndex) => {
        // Find the index of this 'photo' within the 'pswpDataset' (which is fullPhotoDataset)
        // This index is crucial if PhotoSwipe uses a JS dataSource.
        const fullDatasetIndex = pswpDataset.findIndex(
          (p) => p.slug === photo.slug && p.relativePath === photo.relativePath
        )

        const photoSrc = `${imageBaseUrl}${photo.relativePath}` // Original JPEG/PNG src
        const altText = photo.title || photo.description || photo.filename

        // Retrieve the pre-generated data for this photo from photoSwipeJsonData
        // This avoids re-calculating or re-fetching optimized image URLs for the thumbnail's link
        const pswpEntryForThisPhoto = photoSwipeJsonData.find(
          (entry) => entry.slug === photo.slug && entry.downloadUrl === photoSrc
        )

        const calculatedLightboxWidths = getLightboxWidths(photo.width)

        // Pass the true intrinsic dimensions of the photo to getImage for AVIF srcset for the <a> tag.
        // This is still needed if PhotoSwipe falls back to using data attributes from the <a> tag.
        const avifLightboxImages = await getImage({
          src: photoSrc,
          widths: calculatedLightboxWidths,
          width: photo.width, // True intrinsic width
          height: photo.height, // True intrinsic height
          format: "avif",
        })

        // For PhotoSwipe:
        // href: Use the pre-generated medium WebP (src from photoSwipeJsonData) for the link.
        // data-pswp-src: Original JPEG (downloadUrl from photoSwipeJsonData).
        // data-pswp-srcset: AVIF srcset (srcset from photoSwipeJsonData).
        // data-pswp-width/height: Original dimensions.

        const pswpLinkHref = pswpEntryForThisPhoto?.src || photoSrc // Use the 1600px capped WebP, fallback to original
        const pswpDataSrc = pswpEntryForThisPhoto?.downloadUrl || photoSrc // Original JPEG
        const pswpWidth = photo.width
        const pswpHeight = photo.height
        // Use the AVIF srcset generated for the <a> tag directly, or from pswpEntryForThisPhoto if preferred (should be same)
        const pswpSrcset =
          avifLightboxImages?.srcSet?.attribute ||
          pswpEntryForThisPhoto?.srcset ||
          ""

        // Use the two-step classification system to determine caption placement and grid span
        const classification = classifyPhoto(photo.width, photo.height)
        const captionClass = classification.captionClass // 'caption-bottom' or 'caption-side'
        const gridClass = classification.gridClass // 'grid-landscape', 'grid-square', or 'grid-portrait'

        // Calculate optimal image dimensions based on grid layout and caption placement
        // This accounts for: grid columns, gaps, padding, and responsive rem scaling (16px-22px)
        const { displayWidth, sizesAttr } = getImageDimensions(classification)

        // Generate a random rotation for this card (build-time, not runtime)
        const cardRotation = getRandomRotation(1) // Random rotation mostly between -1deg and +1deg

        return (
          <li class={`${captionClass} ${gridClass}`}>
            <a
              class="gallery-item"
              href={pswpLinkHref}
              data-pswp-src={pswpDataSrc}
              data-pswp-width={pswpWidth}
              data-pswp-height={pswpHeight}
              data-pswp-srcset={pswpSrcset}
              data-title={photo.title || ""}
              data-description={photo.description || ""}
              data-date={photo.dateTaken || ""}
              data-tags={photo.tags?.join(",") || ""}
              data-slug={photo.slug || ""}
              data-pswp-index={
                fullDatasetIndex === -1 ? pageSpecificIndex : fullDatasetIndex
              }
              target="_blank"
              aria-label={`View image ${altText}`}
            >
              <figure style={`rotate: ${cardRotation}deg;`}>
                <OptimizedImage
                  src={photoSrc}
                  alt={altText}
                  width={photo.width}
                  height={photo.height}
                  displayWidth={displayWidth}
                  sizesAttr={sizesAttr}
                  loading="lazy"
                  decoding="async"
                />
                <figcaption>{photo.title || photo.filename}</figcaption>
              </figure>
            </a>
          </li>
        )
      })}
    </ul>
  ) : (
    <p>No photos to display.</p>
  )
}

<script>
  // This ensures src/scripts/photoswipe.js is processed by Vite/Astro and included in the build.
  // The script itself (photoswipe.js) will then initialize PhotoSwipe on the #gallery.
  import "../scripts/photoswipe.js"
</script>

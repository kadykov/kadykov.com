---
import OptimizedImage from "./OptimizedImage.astro"
import type { ImageMetadata } from "astro"
import {
  REM_SCALING,
  remToViewport,
  remToPixels,
  formatCalc,
} from "../utils/responsiveConstants"

interface Props {
  src: ImageMetadata | string
  alt: string
  title?: string
}

const { src, alt, title } = Astro.props

// For local images, Astro's Markdoc integration passes ImageMetadata objects
// For remote images, we get a string URL
//
// IMPORTANT: Markdoc integration already accesses ImageMetadata properties,
// which causes Astro to copy the original file. So we can safely check format here.
const isSvg =
  typeof src === "object" &&
  src !== null &&
  "format" in src &&
  src.format === "svg"

/*
 * Article images sizing calculation:
 *
 * Articles have max-width of 30rem with dynamic rem scaling.
 * Base font-size: clamp(16px, 0.395vw + 14.42px, 22px)
 *
 * At narrow viewports (â‰¤32rem), images span full width minus 1rem padding on each side:
 * - Width = 100vw - 2rem
 * - Breakpoint: 32rem = 32 * 16px = 512px (at minimum font size)
 *
 * At wider viewports, images are constrained to article max-width:
 * - Width = 30rem (converted to viewport-relative units)
 *
 * The sizes attribute uses media queries (not clamp) to tell the browser
 * the rendered size at different viewports.
 */
const ARTICLE_MAX_WIDTH_REM = 30
const NARROW_VIEWPORT_PADDING_REM = 2 // 1rem on each side

// Calculate display width at maximum rem value (22px/rem)
const { maxPx: articleMaxWidth } = remToPixels(ARTICLE_MAX_WIDTH_REM)

// Generate sizes attribute using responsive constants
// For narrow viewports: use viewport-relative calculation with padding
// For wide viewports: use article max-width
const { vwComponent, pxComponent } = remToViewport(ARTICLE_MAX_WIDTH_REM)
const { vwComponent: paddingVw, pxComponent: paddingPx } = remToViewport(
  NARROW_VIEWPORT_PADDING_REM
)

// Calculate narrow viewport size: 100vw - 2rem
const narrowVw = 100 - paddingVw
const narrowPx = -paddingPx

// Breakpoint: 32rem (512px at 16px/rem) - where article reaches max-width
const breakpointPx = 32 * REM_SCALING.MIN_PX

const sizesAttr = [
  `(max-width: ${breakpointPx}px) ${formatCalc(narrowVw, narrowPx)}`,
  `(max-width: ${REM_SCALING.MAX_VIEWPORT_PX}px) ${formatCalc(vwComponent, pxComponent)}`,
  `${Math.round(articleMaxWidth)}px`,
].join(", ")

// For SVG, extract dimensions and source
// (Markdoc already accessed these, so no additional harm)
let svgSrc: string | undefined
let svgWidth: number | undefined
let svgHeight: number | undefined

if (isSvg && typeof src === "object") {
  svgSrc = src.src
  svgWidth = src.width
  svgHeight = src.height

  // Scale SVG to article width while maintaining aspect ratio
  if (svgWidth && svgHeight) {
    const aspectRatio = svgHeight / svgWidth
    const scaledWidth = Math.round(articleMaxWidth)
    const scaledHeight = Math.round(scaledWidth * aspectRatio)
    svgWidth = scaledWidth
    svgHeight = scaledHeight
  }
}
---

{
  isSvg && svgSrc ? (
    // SVG: Use directly without optimization (vector graphics scale perfectly)
    title ? (
      <figure>
        <img
          src={svgSrc}
          alt={alt}
          width={svgWidth}
          height={svgHeight}
          loading="lazy"
          decoding="async"
        />
        <figcaption>{title}</figcaption>
      </figure>
    ) : (
      <img
        src={svgSrc}
        alt={alt}
        width={svgWidth}
        height={svgHeight}
        loading="lazy"
        decoding="async"
      />
    )
  ) : // Raster images: Use OptimizedImage component for AVIF conversion
  title ? (
    <figure>
      <OptimizedImage
        src={src}
        alt={alt}
        displayWidth={Math.round(articleMaxWidth)}
        sizesAttr={sizesAttr}
        loading="lazy"
        decoding="async"
      />
      <figcaption>{title}</figcaption>
    </figure>
  ) : (
    <OptimizedImage
      src={src}
      alt={alt}
      displayWidth={Math.round(articleMaxWidth)}
      sizesAttr={sizesAttr}
      loading="lazy"
      decoding="async"
    />
  )
}
